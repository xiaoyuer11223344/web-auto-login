package browser

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/go-rod/rod"
	"github.com/go-rod/rod/lib/proto"
	log "github.com/sirupsen/logrus"
)

type Browser struct {
	browser *rod.Browser
	page    *rod.Page
}

func New() (*Browser, error) {
	browser := rod.New()
	if err := browser.Connect(); err != nil {
		return nil, fmt.Errorf("failed to connect to browser: %w", err)
	}
	return &Browser{browser: browser}, nil
}

func (b *Browser) Close() error {
	if b.page != nil {
		if err := b.page.Close(); err != nil {
			return fmt.Errorf("failed to close page: %w", err)
		}
	}
	if err := b.browser.Close(); err != nil {
		return fmt.Errorf("failed to close browser: %w", err)
	}
	return nil
}

func (b *Browser) IsLoggedIn() bool {
	// Check for common login success indicators
	successIndicators := []string{
		".user-info",
		".user-profile",
		".logout-btn",
		"#logout",
		".welcome-message",
	}

	for _, selector := range successIndicators {
		if el, err := b.page.Element(selector); err == nil && el != nil {
			if visible, _ := el.Visible(); visible {
				return true
			}
		}
	}

	// Check URL for login-related paths
	currentURL := b.page.MustInfo().URL
	loginPaths := []string{"/login", "/signin", "/auth"}
	for _, path := range loginPaths {
		if strings.Contains(currentURL, path) {
			return false
		}
	}

	// Check for error messages
	errorIndicators := []string{
		".error-message",
		".alert-error",
		".login-error",
		".colorR",
	}

	for _, selector := range errorIndicators {
		if el, err := b.page.Element(selector); err == nil && el != nil {
			if visible, _ := el.Visible(); visible {
				return false
			}
		}
	}

	return true
}

func (b *Browser) findElement(selector, name string) (*rod.Element, error) {
	logger := log.WithFields(log.Fields{
		"selector": selector,
		"name":     name,
	})
	logger.Debug("Finding element")

	var el *rod.Element
	var err error

	if strings.HasPrefix(selector, "//") {
		el, err = b.page.ElementX(selector)
	} else {
		el, err = b.page.Element(selector)
	}

	if err != nil {
		return nil, fmt.Errorf("element %s not found: %w", name, err)
	}

	if visible, _ := el.Visible(); !visible {
		return nil, fmt.Errorf("element %s not visible", name)
	}

	logger.Debug("Element found and ready")
	return el, nil
}

func (b *Browser) performLogin(ctx context.Context, selector *Selector, username, password string) error {
	start := time.Now()
	logger := log.WithFields(log.Fields{
		"action": "perform_login",
		"username": username,
		"url": b.page.MustInfo().URL,
	})
	logger.Debug("Starting form interaction")

	// Find elements
	userEl, err := b.findElement(selector.UserInput, "username input")
	if err != nil {
		return fmt.Errorf("failed to find username input: %w", err)
	}

	passEl, err := b.findElement(selector.PasswordInput, "password input")
	if err != nil {
		return fmt.Errorf("failed to find password input: %w", err)
	}

	btnEl, err := b.findElement(selector.LoginBtn, "login button")
	if err != nil {
		return fmt.Errorf("failed to find login button: %w", err)
	}

	logger.Debug("Interacting with form elements")

	// Add small delay before interaction
	time.Sleep(500 * time.Millisecond)

	// Focus and input username
	if err := userEl.WaitStable(2 * time.Second); err == nil {
		if err := userEl.Click(proto.InputMouseButtonLeft, 1); err == nil {
			if err := userEl.Input(username); err != nil {
				return fmt.Errorf("failed to input username: %w", err)
			}
		}
	}

	// Focus and input password
	if err := passEl.WaitStable(2 * time.Second); err == nil {
		if err := passEl.Click(proto.InputMouseButtonLeft, 1); err == nil {
			if err := passEl.Input(password); err != nil {
				return fmt.Errorf("failed to input password: %w", err)
			}
		}
	}

	// Click login button
	if err := btnEl.WaitStable(2 * time.Second); err == nil {
		if err := btnEl.Click(proto.InputMouseButtonLeft, 1); err != nil {
			return fmt.Errorf("failed to click login button: %w", err)
		}
	}

	// Brief wait for form submission
	time.Sleep(500 * time.Millisecond)
	logger.WithField("duration", time.Since(start)).Debug("Login form submitted")
	return nil
}

func (b *Browser) Login(ctx context.Context, selector *Selector, username, password string) error {
	// Create a context with 15-second timeout
	loginCtx, cancel := context.WithTimeout(ctx, 15*time.Second)
	defer cancel()

	start := time.Now()
	logger := log.WithFields(log.Fields{
		"action": "login_attempt",
		"username": username,
		"url": b.page.MustInfo().URL,
	})
	logger.Debug("Starting login attempt")

	// Quick network check
	if err := b.page.WaitIdle(3 * time.Second); err != nil {
		logger.Debug("Network check failed, proceeding anyway")
	}

	// Single login attempt
	if err := b.performLogin(loginCtx, selector, username, password); err != nil {
		return fmt.Errorf("login failed: %w", err)
	}

	// Quick verification
	time.Sleep(1 * time.Second)
	if errEl, err := b.page.Element(".colorR"); err == nil && errEl != nil {
		if text, err := errEl.Text(); err == nil && text != "" {
			return fmt.Errorf("login error: %s", text)
		}
	}

	// Check login success
	if b.IsLoggedIn() {
		logger.WithField("duration", time.Since(start)).Info("Login successful")
		return nil
	}

	return fmt.Errorf("login verification failed")
}

func (b *Browser) Navigate(url string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	logger := log.WithFields(log.Fields{
		"action": "navigate",
		"url": url,
	})

	// Clean up previous session
	if b.page != nil {
		if err := b.Close(); err != nil {
			logger.WithError(err).Debug("Error during cleanup")
		}
	}

	// Create new page
	loginURL := strings.TrimRight(url, "/")
	page, err := b.browser.Page(proto.TargetCreateTarget{URL: loginURL})
	if err != nil {
		return fmt.Errorf("page creation failed: %w", err)
	}
	b.page = page.Context(ctx)

	// Set viewport
	if err = b.page.SetViewport(&proto.EmulationSetDeviceMetricsOverride{
		Width:  1920,
		Height: 1080,
	}); err != nil {
		return fmt.Errorf("viewport setup failed: %w", err)
	}

	// Quick wait for initial load
	if err = b.page.WaitLoad(); err != nil {
		return fmt.Errorf("page load failed: %w", err)
	}

	// Brief network idle check
	if err = b.page.WaitIdle(3 * time.Second); err != nil {
		logger.Debug("Network idle check failed, proceeding anyway")
	}

	// Quick Vue.js app check
	time.Sleep(2 * time.Second)
	if appEl, err := b.page.Element("#app"); err != nil || appEl == nil {
		return fmt.Errorf("Vue.js app not found")
	}

	// Quick form check
	if formEl, err := b.page.Element("form"); err != nil || formEl == nil {
		return fmt.Errorf("login form not found")
	}

	return nil
}
